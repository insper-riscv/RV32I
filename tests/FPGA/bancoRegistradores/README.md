# Register File (FPGA)

This test places the **RV32I register file (32×32 bits)** on the board (e.g., DE0-CV) for direct interaction via **SW**, **KEY**, **LEDs**, and **HEX**.
The idea: choose addresses A/B/C, select a 3-bit data value, **give a “clock step”** with the button, and see the readings on the displays.

#### Test video:

[![Register File Demo (Video in Portuguese)](https://img.youtube.com/vi/6z75OKjMnCE/0.jpg)](https://youtu.be/6z75OKjMnCE?si=i_e1n5RB_PhHB0rD)

## How it works (quick overview)

Top-level: `testeBancoReg`

* The register file clock (`CLK`) is a **pulse** generated by `edgeDetector` from `FPGA_RESET_N`. **Each press** of the reset button (active-low) generates **1 clock cycle** for the file → writes are committed on the edge.
* **x0 is always zero**: reading address 0 returns 0; writing to 0 is ignored.
* The A/B/C addresses are limited to **0..15** (the MSB is forced to 0 in the toplevel).

## I/O Mapping

### Inputs

* `SW[9]` → **escreveC** (write enable, 1 = enables write on the next clock step)
* `SW[8:6]` → **dadoEscritaC** (3 bits, zero-extended to 32b)
* `SW[5:4]` → **endC** (2 bits → becomes 5 bits as `"0" & "00" & SW[5:4]` → addresses 0..15)
* `SW[3:2]` → **endB**
* `SW[1:0]` → **endA**
* `KEY[0]` (active-low) → **clear** for the bank (connected to `not(KEY(0))`)
* `FPGA_RESET_N` (active-low) → **step button** (generates 1 clock pulse via `edgeDetector`)

### Outputs (displays/LEDs)

* `HEX2` ← **saidaA\[3:0]** (lower nibble of data read from A)
* `HEX3` ← **saidaB\[3:0]** (lower nibble of data read from B)
* `HEX4` ← **{0, dadoEscritaC}** (shows the written nibble: 0 + 3 bits of data)
* `HEX0` ← **endA** (nibble of address A)
* `HEX1` ← **endB**
* `HEX5` ← **endC**
* `LEDR[0]` ← `SW[9]` (escreveC)
* `LEDR[1]` ← `not(KEY[0])` (active clear)
* `LEDR[2]` ← `not(FPGA_RESET_N)` (step button pressed)
* `LEDR[3]` ← `CLOCK_50` (board clock — just a visual reference)



