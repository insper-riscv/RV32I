# Makefile para gerar .mif (32-bit words) a partir de um .S RISC-V
# Uso: make FILE=programa.S

AS      := riscv32-unknown-elf-as
LD      := riscv32-unknown-elf-ld
OBJCOPY := riscv32-unknown-elf-objcopy
ARCH    := -march=rv32i -mabi=ilp32

ifeq ($(FILE),)
$(error Uso: make FILE=<arquivo.S>  (ex: make FILE=programa.S))
endif

BASENAME := $(basename $(FILE))

.PHONY: all clean

all: $(BASENAME).mif
	@echo "Gerado: $(BASENAME).mif"

# Gera o binário e depois o .mif
$(BASENAME).mif: $(FILE)
	@echo "Montando: $(FILE)"
	$(AS) $(ARCH) -o $(BASENAME).o $(FILE)
	$(LD) -Ttext=0x0 -o $(BASENAME).elf $(BASENAME).o
	$(OBJCOPY) -O binary $(BASENAME).elf $(BASENAME).bin
	# calcula número de palavras (32-bit) - assume bin size múltiplo de 4
	@BYTES=$$(wc -c < $(BASENAME).bin); \
	if [ $$((BYTES % 4)) -ne 0 ]; then \
	  echo "Aviso: tamanho do binário ($$BYTES bytes) não é múltiplo de 4. O último word será preenchido com zeros."; \
	fi; \
	WORDS=$$(( (BYTES + 3) / 4 )); \
	echo "Tamanho binário: $$BYTES bytes -> $$WORDS palavras (32-bit)"; \
	# cabeçalho MIF
	printf "%s\n" "WIDTH=32;" > $(BASENAME).mif; \
	printf "DEPTH=%d;\n" $$WORDS >> $(BASENAME).mif; \
	printf "ADDRESS_RADIX=HEX;\nDATA_RADIX=HEX;\n\nCONTENT BEGIN\n" >> $(BASENAME).mif; \
	# extrai words (4 bytes) e imprime cada linha com endereço (formato HEX)
	# usamos hexdump para obter 1 word por linha no formato %08X (BIG-ENDIAN de 4 bytes)
	# (isso corresponde ao formato que você usa normalmente)
	hexdump -v -e '1/4 "%08X\n"' $(BASENAME).bin | awk -v OFS="" '{ printf "%04X : %s;\n", NR-1, $$0 }' >> $(BASENAME).mif; \
	# se quiser preencher o restante com zeros (não necessário se DEPTH == WORDS)
	printf "END\n" >> $(BASENAME).mif; \
	# limpeza temporária intermediária
	rm -f $(BASENAME).o $(BASENAME).elf $(BASENAME).bin

clean:
	@find . -maxdepth 1 -type f \( -name "*.o" -o -name "*.elf" -o -name "*.bin" -o -name "*.mif" \) -delete
	@echo "Limpeza concluída"
